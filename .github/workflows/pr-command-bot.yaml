name: PR Command Bot

on:
  pull_request_review_comment:
    types: [created]
  pull_request:
    types: [opened, closed, reopened, edited]  # Add 'edited' to handle PR description updates

permissions:
  issues: write
  pull-requests: write

jobs:
  process-command:
    runs-on: ubuntu-latest
    steps:
      - name: Process PR Commands
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment?.body?.trim().toLowerCase();
            const commenter = context.payload.comment?.user?.login;
            const prNumber = context.payload.pull_request?.number;  // Fix: Changed from # to //
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const action = context.payload.action;

            const isPR = context.payload.pull_request !== undefined;

            // Helper function to check if user is a maintainer
            async function isMaintainer(username) {
              try {
                const { data: collaborators } = await github.rest.repos.listCollaborators({
                  owner: repoOwner,
                  repo: repoName,
                  affiliation: 'direct'
                });
                return collaborators.some(collab => 
                  collab.login === username && 
                  ['admin', 'write'].includes(collab.permissions?.pull)
                );
              } catch (error) {
                console.error('Error checking maintainer status:', error);
                return false;
              }
            }

            // Helper function to handle labels
            async function handleLabel(labelName, color, description) {
              try {
                await github.rest.issues.addLabels({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  labels: [labelName]
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: repoOwner,
                    repo: repoName,
                    name: labelName,
                    color: color || "0e8a16",
                    description: description || ""
                  });
                  
                  await github.rest.issues.addLabels({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    labels: [labelName]
                  });
                } else {
                  throw error;
                }
              }
            }

            // Helper function to request reviews
            async function requestReviews(usernames, commandType) {
              if (!isPR) {
                throw new Error(`${commandType} command can only be used on pull requests`);
              }

              const cleanUsernames = usernames
                .map(name => name.replace(/^@/, '').trim())
                .filter(name => name && name !== commenter); // Filter out empty and self-reviews

              if (cleanUsernames.length === 0) {
                throw new Error('No valid reviewers specified');
              }

              await github.rest.pulls.requestReviewers({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber,
                reviewers: cleanUsernames
              });

              return cleanUsernames;
            }

            // Process /kind flag in PR description
            if ((action === "opened" || action === "edited") && isPR) {
              const description = context.payload.pull_request?.body?.trim() || "";
              // Improved regex to handle different formatting
              const kindMatch = description.match(/\/kind\s*:\s*(\S+)|\/kind\s+(\S+)/i);
              
              if (kindMatch) {
                const kindValue = (kindMatch[1] || kindMatch[2]).toLowerCase();
                const kindLabel = `kind/${kindValue}`;
                
                try {
                  // First try to add the label
                  await github.rest.issues.addLabels({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    labels: [kindLabel]
                  });
                } catch (error) {
                  if (error.status === 404) {
                    try {
                      // Create the kind label if it doesn't exist
                      await github.rest.issues.createLabel({
                        owner: repoOwner,
                        repo: repoName,
                        name: kindLabel,
                        color: "696969",  // Dark gray
                        description: `PR type: ${kindValue}`
                      });

                      // Try adding the label again
                      await github.rest.issues.addLabels({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        labels: [kindLabel]
                      });
                    } catch (createError) {
                      // Comment on PR if label operations failed
                      await github.rest.issues.createComment({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        body: `Failed to add kind label: ${kindLabel}. Please check if the kind type is valid.`
                      });
                    }
                  } else {
                    // Comment on PR for other errors
                    await github.rest.issues.createComment({
                      owner: repoOwner,
                      repo: repoName,
                      issue_number: prNumber,
                      body: `Error processing /kind command: ${error.message}`
                    });
                  }
                }
              }
            }

            // /assign command for PR (only for PR events)
            if (comment === "/assign" && isPR && action === "created") {
              await github.rest.pulls.requestReviewers({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber,
                reviewers: [commenter]
              });
            }

            // /close command for PR
            if (comment?.startsWith("/close ") && action === "created") {
              const closeReason = comment.replace("/close ", "").trim();

              let reason = "";

              if (closeReason === "not-planned") {
                reason = "Not planned";
              } else if (closeReason === "completed") {
                reason = "Completed";
              } else if (closeReason === "inactive") {
                reason = "Inactive";
              } else if (closeReason === "duplicate") {
                reason = "Duplicate";
              } else {
                reason = "Closed"; // Default case
              }

              await github.rest.pulls.update({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber,
                state: "closed"
              });
            }

            // /reopen command for PR
            if (comment === "/reopen" && action === "created") {
              await github.rest.pulls.update({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber,
                state: "open"
              });
            }

            // /merge command for PR
            if (comment === "/merge" && action === "created") {
              await github.rest.pulls.merge({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber,
              });
            }

            // /label command for PR
            if (comment?.startsWith("/label ") && action === "created") {
              const labelName = comment.replace("/label ", "").trim();
  
              if (labelName) {
                try {
                  await github.rest.issues.addLabels({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,  
                    labels: [labelName]
                  });
                } catch (error) {
                  if (error.status === 404) {
                    await github.rest.issues.createLabel({
                      owner: repoOwner,
                      repo: repoName,
                      name: labelName,
                      color: "0e8a16" 
                    });

                    await github.rest.issues.addLabels({
                      owner: repoOwner,
                      repo: repoName,
                      issue_number: prNumber,
                      labels: [labelName]
                    });
                  } else {
                    throw error;
                  }
                }
              }
            }

            // /review command for PR - request reviews from others
            if (comment?.startsWith("/review") && action === "created") {
              try {
                const reviewers = comment
                  .substring(7)
                  .trim()
                  .split(/[\s,]+/);

                const added = await requestReviews(reviewers, "/review");
                await github.rest.issues.createComment({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  body: `✅ Requested review from: ${added.map(r => '@' + r).join(', ')}`
                });
              } catch (error) {
                await github.rest.issues.createComment({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  body: `❌ Error: ${error.message}`
                });
              }
            }

            // /cc command for requesting reviews
            if (comment?.startsWith("/cc") && action === "created") {
              try {
                const reviewers = comment
                  .substring(3)  // Remove '/cc'
                  .trim()
                  .split(/[\s,]+/);  // Split by whitespace or commas

                const added = await requestReviews(reviewers, "/cc");
                await github.rest.issues.createComment({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  body: `✅ Requested review from: ${added.map(r => '@' + r).join(', ')}`
                });
              } catch (error) {
                await github.rest.issues.createComment({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  body: `❌ Error: ${error.message}`
                });
              }
            }

            // /lgtm command for maintainers
            if (comment === "/lgtm" && action === "created") {
              try {
                if (!isPR) {
                  throw new Error("/lgtm command can only be used on pull requests");
                }

                // Check if commenter is the PR author
                const prAuthor = context.payload.pull_request.user.login;
                if (commenter === prAuthor) {
                  throw new Error("You cannot LGTM your own pull request");
                }

                if (!(await isMaintainer(commenter))) {
                  throw new Error("Only maintainers can use the /lgtm command");
                }

                await handleLabel("lgtm", "0e8a16", "Looks Good To Me - Approved by maintainer");
                
                // Add approval review
                await github.rest.pulls.createReview({
                  owner: repoOwner,
                  repo: repoName,
                  pull_number: prNumber,
                  event: 'APPROVE',
                  body: '👍 LGTM! Approved by maintainer.'
                });

                await github.rest.issues.createComment({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  body: `✅ @${commenter} has approved this pull request with LGTM`
                });
              } catch (error) {
                await github.rest.issues.createComment({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  body: `❌ Error: ${error.message}`
                });
              }
            }

            // /approve command for maintainers
            if (comment?.startsWith("/approve") && action === "created") {
              if (await isMaintainer(commenter)) {
                const isCancel = comment.includes("cancel");
                const approvedLabel = "approved";
                
                if (isCancel) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: repoOwner,
                      repo: repoName,
                      issue_number: prNumber,
                      name: approvedLabel
                    });
                  } catch (error) {
                    if (error.status !== 404) { // Ignore if label doesn't exist
                      throw error;
                    }
                  }
                } else {
                  try {
                    await github.rest.issues.addLabels({
                      owner: repoOwner,
                      repo: repoName,
                      issue_number: prNumber,
                      labels: [approvedLabel]
                    });
                  } catch (error) {
                    if (error.status === 404) {
                      await github.rest.issues.createLabel({
                        owner: repoOwner,
                        repo: repoName,
                        name: approvedLabel,
                        color: "28a745", // GitHub green
                        description: "Pull request has been approved by a maintainer"
                      });

                      await github.rest.issues.addLabels({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        labels: [approvedLabel]
                      });
                    } else {
                      throw error;
                    }
                  }
                }
              }
            }
