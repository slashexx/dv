name: PR Command Bot

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request:
    types: [opened, closed, reopened, edited]  

permissions:
  issues: write
  pull-requests: write

jobs:
  process-command:
    runs-on: ubuntu-latest
    steps:
      - name: Process PR Commands
        uses: actions/github-script@v7
        with:
          script: |
            // Determine event type and get comment details
            const eventName = context.eventName;
            let comment, commenter, action, prNumber;

            console.log("Event type:", eventName);

            // Handle different event types
            if (eventName === 'issue_comment') {
              // Only process if this is a PR comment
              if (!context.payload.issue.pull_request) {
                console.log("Skipping - not a PR comment");
                return;
              }
              comment = context.payload.comment?.body?.trim().toLowerCase();
              commenter = context.payload.comment?.user?.login;
              prNumber = context.payload.issue.number;
              action = context.payload.action;
            } else if (eventName === 'pull_request_review_comment') {
              comment = context.payload.comment?.body?.trim().toLowerCase();
              commenter = context.payload.comment?.user?.login;
              prNumber = context.payload.pull_request.number;
              action = context.payload.action;
            } else if (eventName === 'pull_request') {
              prNumber = context.payload.pull_request.number;
              action = context.payload.action;
            }

            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;

            console.log("Processing:", {
              comment,
              commenter,
              action,
              prNumber,
              eventName
            });

            // Get PR details if needed
            let prAuthor;
            if (eventName === 'issue_comment') {
              const { data: pr } = await github.rest.pulls.get({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber
              });
              prAuthor = pr.user.login;
            } else if (eventName === 'pull_request' || eventName === 'pull_request_review_comment') {
              prAuthor = context.payload.pull_request.user.login;
            }

            // Helper function to check if user is a maintainer
            async function isMaintainer(username) {
              try {
                const { data: collaborators } = await github.rest.repos.listCollaborators({
                  owner: repoOwner,
                  repo: repoName,
                  affiliation: 'direct'
                });
                return collaborators.some(collab => 
                  collab.login === username && 
                  ['admin', 'write'].includes(collab.permissions?.pull)
                );
              } catch (error) {
                console.error('Error checking maintainer status:', error);
                return false;
              }
            }

            // Helper function to handle labels
            async function handleLabel(labelName, color, description) {
              try {
                await github.rest.issues.addLabels({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: prNumber,
                  labels: [labelName]
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: repoOwner,
                    repo: repoName,
                    name: labelName,
                    color: color || "0e8a16",
                    description: description || ""
                  });
                  
                  await github.rest.issues.addLabels({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    labels: [labelName]
                  });
                } else {
                  throw error;
                }
              }
            }

            // Simpler helper function to request reviews
            async function requestReviews(reviewers) {
              const validReviewers = reviewers
                .map(r => r.replace(/^@/, '').trim())
                .filter(r => r);

              if (validReviewers.length === 0) {
                throw new Error('No valid reviewers specified');
              }

              console.log("Requesting reviews from:", validReviewers);

              await github.rest.pulls.requestReviewers({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNumber,
                reviewers: validReviewers
              });

              return validReviewers;
            }

            // Add isPR check
            const isPR = !!context.payload.pull_request || !!context.payload.issue?.pull_request;

            try {
              // /cc command for requesting reviews
              if (comment?.includes("/cc") && action === "created") {
                try {
                  const reviewers = comment
                    .substring(3)  // Remove '/cc'
                    .trim()
                    .split(/[\s,]+/);  // Split by whitespace or commas

                  const added = await requestReviews(reviewers);
                  await github.rest.issues.createComment({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    body: `✅ Requested review from: ${added.map(r => '@' + r).join(', ')}`
                  });
                } catch (error) {
                  await github.rest.issues.createComment({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    body: `❌ Error: ${error.message}`
                  });
                }
              }

              if (comment?.includes("/lgtm")) {
                try {
                  if (commenter === prAuthor) {
                    throw new Error("You cannot LGTM your own pull request");
                  }

                  await handleLabel("lgtm", "0e8a16", "Looks Good To Me");
                  
                  await github.rest.issues.createComment({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    body: `✅ @${commenter} has marked this pull request as LGTM`
                  });
                } catch (error) {
                  console.error("Error in /lgtm command:", error);
                  await github.rest.issues.createComment({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    body: `❌ ${error.message}`
                  });
                }
              }

              // /assign command for PR (only for PR events)
              if (comment?.includes("/assign") && isPR && action === "created") {
                await github.rest.pulls.requestReviewers({
                  owner: repoOwner,
                  repo: repoName,
                  pull_number: prNumber,
                  reviewers: [commenter]
                });
              }

              // /close command for PR
              if (comment?.includes("/close") && action === "created") {
                const closeReason = parseCommand(comment, "/close");

                let reason = "";

                if (closeReason === "not-planned") {
                  reason = "Not planned";
                } else if (closeReason === "completed") {
                  reason = "Completed";
                } else if (closeReason === "inactive") {
                  reason = "Inactive";
                } else if (closeReason === "duplicate") {
                  reason = "Duplicate";
                } else {
                  reason = "Closed"; // Default case
                }

                await github.rest.pulls.update({
                  owner: repoOwner,
                  repo: repoName,
                  pull_number: prNumber,
                  state: "closed"
                });
              }

              // /reopen command for PR
              if (comment?.includes("/reopen") && action === "created") {
                await github.rest.pulls.update({
                  owner: repoOwner,
                  repo: repoName,
                  pull_number: prNumber,
                  state: "open"
                });
              }

              // /merge command for PR
              if (comment?.includes("/merge") && action === "created") {
                await github.rest.pulls.merge({
                  owner: repoOwner,
                  repo: repoName,
                  pull_number: prNumber,
                });
              }

              // /label command for PR
              if (comment?.includes("/label") && action === "created") {
                const labelName = parseCommand(comment, "/label");

                if (labelName) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: repoOwner,
                      repo: repoName,
                      issue_number: prNumber,  
                      labels: [labelName]
                    });
                  } catch (error) {
                    if (error.status === 404) {
                      await github.rest.issues.createLabel({
                        owner: repoOwner,
                        repo: repoName,
                        name: labelName,
                        color: "0e8a16" 
                      });

                      await github.rest.issues.addLabels({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        labels: [labelName]
                      });
                    } else {
                      throw error;
                    }
                  }
                }
              }

              // /approve command for maintainers
              if (comment?.includes("/approve") && action === "created") {
                console.log("Processing /approve command from:", commenter);
                
                const isMaintainerResult = await isMaintainer(commenter);
                console.log("Is maintainer check result:", isMaintainerResult);
                
                if (isMaintainerResult) {
                  const isCancel = comment.includes("cancel");
                  const approvedLabel = "approved";
                  
                  if (isCancel) {
                    console.log("Processing approval cancellation");
                    try {
                      // Remove approval review
                      await github.rest.pulls.createReview({
                        owner: repoOwner,
                        repo: repoName,
                        pull_number: prNumber,
                        event: 'DISMISS',
                        body: 'Approval cancelled'
                      });
                      
                      // Remove label
                      await github.rest.issues.removeLabel({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        name: approvedLabel
                      });
                      
                      await github.rest.issues.createComment({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        body: `✅ @${commenter} has cancelled their approval`
                      });
                    } catch (error) {
                      console.error("Error cancelling approval:", error);
                      if (error.status !== 404) { // Ignore if label doesn't exist
                        throw error;
                      }
                    }
                  } else {
                    console.log("Processing new approval");
                    try {
                      // Submit approval review
                      await github.rest.pulls.createReview({
                        owner: repoOwner,
                        repo: repoName,
                        pull_number: prNumber,
                        event: 'APPROVE',
                        body: 'Approved via command'
                      });
                      
                      // Add label
                      try {
                        await github.rest.issues.addLabels({
                          owner: repoOwner,
                          repo: repoName,
                          issue_number: prNumber,
                          labels: [approvedLabel]
                        });
                      } catch (error) {
                        if (error.status === 404) {
                          await github.rest.issues.createLabel({
                            owner: repoOwner,
                            repo: repoName,
                            name: approvedLabel,
                            color: "28a745",
                            description: "Pull request has been approved by a maintainer"
                          });

                          await github.rest.issues.addLabels({
                            owner: repoOwner,
                            repo: repoName,
                            issue_number: prNumber,
                            labels: [approvedLabel]
                          });
                        } else {
                          throw error;
                        }
                      }
                      
                      await github.rest.issues.createComment({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        body: `✅ @${commenter} has approved this pull request`
                      });
                    } catch (error) {
                      console.error("Error approving PR:", error);
                      throw error;
                    }
                  }
                } else {
                  await github.rest.issues.createComment({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: prNumber,
                    body: `❌ @${commenter} does not have permission to approve pull requests`
                  });
                }
              }

              // Process PR description commands
              if ((action === "opened" || action === "edited") && eventName === 'pull_request') {
                const description = context.payload.pull_request?.body?.trim() || "";
                // Improved regex to handle different formatting
                const kindMatch = description.match(/\/kind\s*:\s*(\S+)|\/kind\s+(\S+)/i);
                
                if (kindMatch) {
                  const kindValue = (kindMatch[1] || kindMatch[2]).toLowerCase();
                  const kindLabel = `kind/${kindValue}`;
                  
                  try {
                    await github.rest.issues.addLabels({
                      owner: repoOwner,
                      repo: repoName,
                      issue_number: prNumber,
                      labels: [kindLabel]
                    });
                  } catch (error) {
                    if (error.status === 404) {
                      try {
                        await github.rest.issues.createLabel({
                          owner: repoOwner,
                          repo: repoName,
                          name: kindLabel,
                          color: "696969",  // Dark gray
                          description: `PR type: ${kindValue}`
                        });

                        // Try adding the label again
                        await github.rest.issues.addLabels({
                          owner: repoOwner,
                          repo: repoName,
                          issue_number: prNumber,
                          labels: [kindLabel]
                        });
                      } catch (createError) {
                        // Comment on PR if label operations failed
                        await github.rest.issues.createComment({
                          owner: repoOwner,
                          repo: repoName,
                          issue_number: prNumber,
                          body: `Failed to add kind label: ${kindLabel}. Please check if the kind type is valid.`
                        });
                      }
                    } else {
                      // Comment on PR for other errors
                      await github.rest.issues.createComment({
                        owner: repoOwner,
                        repo: repoName,
                        issue_number: prNumber,
                        body: `Error processing /kind command: ${error.message}`
                      });
                    }
                  }
                }
              }
            } catch (error) {
              console.error("Error processing command:", error);
              await github.rest.issues.createComment({
                owner: repoOwner,
                repo: repoName,
                issue_number: prNumber,
                body: `❌ Error: ${error.message}`
              });
            }
